## Примечание:
- комментарии, помеченные как "opt" являются опциональными к правке. Остается на ваш вкус.

## Недостатки
- наименование пакета "metty1337.currencyexchange" не соответствует правилам нейминга. Можно почитать в конвенциях о нейминге в java
### pom.xml
- В проекте нет тестов, но присутствуют зависимости в test scope (jUnit и тд). Они точно тут нужны?
- Нет единообразия в вынесении в переменные версий зависимостей. Лучше выносить все как тут: <junit.version>5.11.0</junit.version>
### Миграции
- В SQL стандартом является snake_case, а не camelCase
- Для rate более уместно увеличить точность - DECIMAL(10, 6)
- Отсутствует индекс по валютной паре. Без индекс при росте данных запросы на чтение по валютной паре будут запускать скан всей таблицы.
### CurrenciesColumns
- Название не отражает ответственность
- opt: На мой вкус, но это избыточно. Названия в колонках вряд ли поменяются, поэтому не совсем понятно для чего нужен этот enum
### ExchangeRatesColumns
- Название не отражает ответственность
- opt: На мой вкус, но это избыточно. Названия в колонках вряд ли поменяются, поэтому не совсем понятно для чего нужен этот enum
### DatabaseConnection
- Название не отражает ответственность. Лучше ConnectionFactory
- Закомментированного кода быть не должно
- PRAGMA foreign_keys = ON лучше перенести в миграции. Сейчас поведение не очевидное, тогда отпадет необходимость получать statement. Сейчас для того, чтобы получить соединение этот код отправляет запрос на изменение конфигурации БД. Неочевидное поведение
### DatabaseMigrator
- String URL не соответствует стилю нейминга. Должно быть String url 
### JsonManager
- Название не отражает ответственность. Лучше JsonResponseWriter
- Нет отступов между методами и полями
- Проброс RuntimeException - плохая практика. Нужно кастомное исключение, как в других случаях, например в DatabaseConnection
### ValidatorManager
- Manager в названиях - антипаттерн
- Менеджером можно назвать все что угодно и никогда не понятно что именно делает класс. По названию я должен понять ответственность, не вникая в детали реализации. Лучше ValidationUtils или Validator
### CurrencyDAO
- opt: я на реальных проектах не встречал неймингов в UPPERCASE. Лучше CurrencyDao
- В findByCode и findByCode лучше возвращать Optional<Currency>. Будет проще работать с кейсами, когда значения не найдено в БД
### ExchangeRateDAO
- аналогично комментам выше
### JdbcCurrencyDAO
- Указание CURRENCY в статических переменных избыточно, т.к класс и так отвечает за валюту. Вместо SELECT_ALL_CURRENCIES можно SELECT_ALL и тд.
- Стоит использовать PreparedStatement вместо Statement
- mapRow: catch (Exception e) {throw new RuntimeException(e);} - такую конструкцию не стоит использовать. Ловите конкретные исключения и бросайте кастомные. Пример: catch (SQLException e) {throw new DataAccessException("Failed to map currency from ResultSet", e); }
### JdbcExchangeRateDAO
- аналогично выше
- SELECT_COUNT_EXCHANGE_RATES_BY_IDS не используется
- Integer Id = exchangeRate.getID() - это не в рамках нейминга. Нужно Integer id = exchangeRate.getId(). p.s Intellij Idea мне подсветила эти проблемы, поэтому у вас они тоже должны были быть видны.
### ErrorCell
- Название ErrorCell не очень удачное. Лучше ErrorMessage или ErrorResponse
### ErrorMessages
- название не соответствует стилю java. Если есть желание выносить такие константы, то enum вряд ли нужен. Тем более enum с 1 элементом. Суть энума в перечислении нескольких элементов
### CurrencyServiceFactory, ExchangeRateServiceFactory
- Антипаттерн.
- Жесткие зависимости - нельзя подменить реализации
- Тестирование сложно - нельзя использовать моки
- Нарушение DIP - высокоуровневый модуль зависит от низкоуровневых
- Скрытые зависимости - не видно что нужно для CurrencyService
- Решение - DI (Dependency Injection) через конструктор. Стоит уделить время на изучения этого паттерна. Далее этот паттерн будет использоваться в Spring
### package filter
- Двигаетесь в верном направлении для разделения ответственностей. Но нужно рефакторить дублирование и выделить общую логику в базовые классы и утилиты
- Но я бы вынес валидацию в сервисный слой. Так проще тестировать (на мой взгляд)
### CurrencyMapper
- @NoArgsConstructor - избыточно
- Наверное хочется такой же маппер для курса валют
### Currency, ExchangeRate
- Нарушение конвенций нейминга всех полей
### CurrencyService
- Если в getCurrencyByCode и getCurrencyById не найдется значений, то вылетит NullPointerException, которое поломает логику 
### ExchangeRateService
- Если в findByCurrencyIds не найдется значений, то вылетит NullPointerException, которое поломает логику
- isExchangeRateExist стоит переписать иначе. Если не найдется курса, то вернется null. В этом случае делаем вашу бизнес логику, в обратном другое. Исключения тут - переусложнение
- exchange очень тяжело читать. Нужна разбивка на приватные методы
### package servlets
- Зависимости (слой сервисов) не должны быть изменяемыми. Так быть не должно, как писал выше DI контейнер решает проблему поставок зависимостей
- init уйдет после внедрения через DI контейнер
- try-catch не должен быть в сервлетах. Логики вообще не должно быть (вся логика в сервисах). Как вариант -  ExceptionHandlerFilter implements Filter, который будет отлавливать исключения и устанавливать корректные статус и сообщения в ответ

## Итог:
- Чистая слоистая архитектура (Controller-Service-DAO)
- Правильное разделение ответственности между компонентами
- Единообразные REST-эндпоинты с соответствующими HTTP-методами
- Осознанное использование DTO для передачи данных между слоями
- Кастомные исключения с семантическим смыслом
- Миграции базы данных - признак зрелого проекта
- Подготовка JSON-ответов единообразно
- После рефакторинга и работы над ошибками можно смело двигаться дальше. Очень достойный проект!
